/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type ErrorWithCode = Error & { code: number }
type MaybeErrorWithCode = ErrorWithCode | null | undefined

const createErrorFromCodeLookup: Map<number, () => ErrorWithCode> = new Map()
const createErrorFromNameLookup: Map<string, () => ErrorWithCode> = new Map()

/**
 * AccountShouldBeSigner: 'Account should be signer'
 *
 * @category Errors
 * @category generated
 */
export class AccountShouldBeSignerError extends Error {
  readonly code: number = 0x11c7ac
  readonly name: string = 'AccountShouldBeSigner'
  constructor() {
    super('Account should be signer')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, AccountShouldBeSignerError)
    }
  }
}

createErrorFromCodeLookup.set(0x11c7ac, () => new AccountShouldBeSignerError())
createErrorFromNameLookup.set(
  'AccountShouldBeSigner',
  () => new AccountShouldBeSignerError()
)

/**
 * ProvidedAtaIsIncorrect: 'Provided ATA does not match the expected ATA'
 *
 * @category Errors
 * @category generated
 */
export class ProvidedAtaIsIncorrectError extends Error {
  readonly code: number = 0x11c7ad
  readonly name: string = 'ProvidedAtaIsIncorrect'
  constructor() {
    super('Provided ATA does not match the expected ATA')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, ProvidedAtaIsIncorrectError)
    }
  }
}

createErrorFromCodeLookup.set(0x11c7ad, () => new ProvidedAtaIsIncorrectError())
createErrorFromNameLookup.set(
  'ProvidedAtaIsIncorrect',
  () => new ProvidedAtaIsIncorrectError()
)

/**
 * AccountNotFunded: 'Account not funded'
 *
 * @category Errors
 * @category generated
 */
export class AccountNotFundedError extends Error {
  readonly code: number = 0x11c7ae
  readonly name: string = 'AccountNotFunded'
  constructor() {
    super('Account not funded')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, AccountNotFundedError)
    }
  }
}

createErrorFromCodeLookup.set(0x11c7ae, () => new AccountNotFundedError())
createErrorFromNameLookup.set(
  'AccountNotFunded',
  () => new AccountNotFundedError()
)

/**
 * ExceedingMaxSupportedSolutions: 'Amount of solutions exceeds maximum supported solutions '
 *
 * @category Errors
 * @category generated
 */
export class ExceedingMaxSupportedSolutionsError extends Error {
  readonly code: number = 0x11c7af
  readonly name: string = 'ExceedingMaxSupportedSolutions'
  constructor() {
    super('Amount of solutions exceeds maximum supported solutions ')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, ExceedingMaxSupportedSolutionsError)
    }
  }
}

createErrorFromCodeLookup.set(
  0x11c7af,
  () => new ExceedingMaxSupportedSolutionsError()
)
createErrorFromNameLookup.set(
  'ExceedingMaxSupportedSolutions',
  () => new ExceedingMaxSupportedSolutionsError()
)

/**
 * NoSolutionsToAddProvided: 'When adding solutions you need to provide at least one solution'
 *
 * @category Errors
 * @category generated
 */
export class NoSolutionsToAddProvidedError extends Error {
  readonly code: number = 0x11c7b0
  readonly name: string = 'NoSolutionsToAddProvided'
  constructor() {
    super('When adding solutions you need to provide at least one solution')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, NoSolutionsToAddProvidedError)
    }
  }
}

createErrorFromCodeLookup.set(
  0x11c7b0,
  () => new NoSolutionsToAddProvidedError()
)
createErrorFromNameLookup.set(
  'NoSolutionsToAddProvided',
  () => new NoSolutionsToAddProvidedError()
)

/**
 * AccountAlreadyExists: 'Account was expected to not exists yet, but it does'
 *
 * @category Errors
 * @category generated
 */
export class AccountAlreadyExistsError extends Error {
  readonly code: number = 0x11c7b1
  readonly name: string = 'AccountAlreadyExists'
  constructor() {
    super('Account was expected to not exists yet, but it does')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, AccountAlreadyExistsError)
    }
  }
}

createErrorFromCodeLookup.set(0x11c7b1, () => new AccountAlreadyExistsError())
createErrorFromNameLookup.set(
  'AccountAlreadyExists',
  () => new AccountAlreadyExistsError()
)

/**
 * AccountAlreadyHasData: 'Account has data but was expected to be empty'
 *
 * @category Errors
 * @category generated
 */
export class AccountAlreadyHasDataError extends Error {
  readonly code: number = 0x11c7b2
  readonly name: string = 'AccountAlreadyHasData'
  constructor() {
    super('Account has data but was expected to be empty')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, AccountAlreadyHasDataError)
    }
  }
}

createErrorFromCodeLookup.set(0x11c7b2, () => new AccountAlreadyHasDataError())
createErrorFromNameLookup.set(
  'AccountAlreadyHasData',
  () => new AccountAlreadyHasDataError()
)

/**
 * AccountHasNoData: 'Account has no data'
 *
 * @category Errors
 * @category generated
 */
export class AccountHasNoDataError extends Error {
  readonly code: number = 0x11c7b3
  readonly name: string = 'AccountHasNoData'
  constructor() {
    super('Account has no data')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, AccountHasNoDataError)
    }
  }
}

createErrorFromCodeLookup.set(0x11c7b3, () => new AccountHasNoDataError())
createErrorFromNameLookup.set(
  'AccountHasNoData',
  () => new AccountHasNoDataError()
)

/**
 * ChallengeAlreadyStarted: 'Challenge was started already and cannot be started again'
 *
 * @category Errors
 * @category generated
 */
export class ChallengeAlreadyStartedError extends Error {
  readonly code: number = 0x11c7b4
  readonly name: string = 'ChallengeAlreadyStarted'
  constructor() {
    super('Challenge was started already and cannot be started again')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, ChallengeAlreadyStartedError)
    }
  }
}

createErrorFromCodeLookup.set(
  0x11c7b4,
  () => new ChallengeAlreadyStartedError()
)
createErrorFromNameLookup.set(
  'ChallengeAlreadyStarted',
  () => new ChallengeAlreadyStartedError()
)

/**
 * ChallengeHasNoSolutions: 'Challenge has no solutions and thus cannot be started'
 *
 * @category Errors
 * @category generated
 */
export class ChallengeHasNoSolutionsError extends Error {
  readonly code: number = 0x11c7b5
  readonly name: string = 'ChallengeHasNoSolutions'
  constructor() {
    super('Challenge has no solutions and thus cannot be started')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, ChallengeHasNoSolutionsError)
    }
  }
}

createErrorFromCodeLookup.set(
  0x11c7b5,
  () => new ChallengeHasNoSolutionsError()
)
createErrorFromNameLookup.set(
  'ChallengeHasNoSolutions',
  () => new ChallengeHasNoSolutionsError()
)

/**
 * ChallengeNotYetStarted: 'Challenge has not started yet and is not ready to admit challengers'
 *
 * @category Errors
 * @category generated
 */
export class ChallengeNotYetStartedError extends Error {
  readonly code: number = 0x11c7b6
  readonly name: string = 'ChallengeNotYetStarted'
  constructor() {
    super('Challenge has not started yet and is not ready to admit challengers')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, ChallengeNotYetStartedError)
    }
  }
}

createErrorFromCodeLookup.set(0x11c7b6, () => new ChallengeNotYetStartedError())
createErrorFromNameLookup.set(
  'ChallengeNotYetStarted',
  () => new ChallengeNotYetStartedError()
)

/**
 * ChallengeAlreadyFinished: 'Challenge was finished already and is not admitting challengers nor allowing to redeem prices'
 *
 * @category Errors
 * @category generated
 */
export class ChallengeAlreadyFinishedError extends Error {
  readonly code: number = 0x11c7b7
  readonly name: string = 'ChallengeAlreadyFinished'
  constructor() {
    super(
      'Challenge was finished already and is not admitting challengers nor allowing to redeem prices'
    )
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, ChallengeAlreadyFinishedError)
    }
  }
}

createErrorFromCodeLookup.set(
  0x11c7b7,
  () => new ChallengeAlreadyFinishedError()
)
createErrorFromNameLookup.set(
  'ChallengeAlreadyFinished',
  () => new ChallengeAlreadyFinishedError()
)

/**
 * SolutionIsIncorrect: 'The provided solution did not match the currently expected solution'
 *
 * @category Errors
 * @category generated
 */
export class SolutionIsIncorrectError extends Error {
  readonly code: number = 0x11c7b8
  readonly name: string = 'SolutionIsIncorrect'
  constructor() {
    super('The provided solution did not match the currently expected solution')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, SolutionIsIncorrectError)
    }
  }
}

createErrorFromCodeLookup.set(0x11c7b8, () => new SolutionIsIncorrectError())
createErrorFromNameLookup.set(
  'SolutionIsIncorrect',
  () => new SolutionIsIncorrectError()
)

/**
 * OutOfSolutions: 'All solutions were already redeemed'
 *
 * @category Errors
 * @category generated
 */
export class OutOfSolutionsError extends Error {
  readonly code: number = 0x11c7b9
  readonly name: string = 'OutOfSolutions'
  constructor() {
    super('All solutions were already redeemed')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, OutOfSolutionsError)
    }
  }
}

createErrorFromCodeLookup.set(0x11c7b9, () => new OutOfSolutionsError())
createErrorFromNameLookup.set('OutOfSolutions', () => new OutOfSolutionsError())

/**
 * ChallengerHasNoTriesRemaining: 'This challenger used up all tries to solve the challenge'
 *
 * @category Errors
 * @category generated
 */
export class ChallengerHasNoTriesRemainingError extends Error {
  readonly code: number = 0x11c7ba
  readonly name: string = 'ChallengerHasNoTriesRemaining'
  constructor() {
    super('This challenger used up all tries to solve the challenge')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, ChallengerHasNoTriesRemainingError)
    }
  }
}

createErrorFromCodeLookup.set(
  0x11c7ba,
  () => new ChallengerHasNoTriesRemainingError()
)
createErrorFromNameLookup.set(
  'ChallengerHasNoTriesRemaining',
  () => new ChallengerHasNoTriesRemainingError()
)

/**
 * InsufficientFunds: 'Payer does not have sufficient lamports to fund the operation'
 *
 * @category Errors
 * @category generated
 */
export class InsufficientFundsError extends Error {
  readonly code: number = 0x11c7bb
  readonly name: string = 'InsufficientFunds'
  constructor() {
    super('Payer does not have sufficient lamports to fund the operation')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, InsufficientFundsError)
    }
  }
}

createErrorFromCodeLookup.set(0x11c7bb, () => new InsufficientFundsError())
createErrorFromNameLookup.set(
  'InsufficientFunds',
  () => new InsufficientFundsError()
)

/**
 * Attempts to resolve a custom program error from the provided error code.
 * @category Errors
 * @category generated
 */
export function errorFromCode(code: number): MaybeErrorWithCode {
  const createError = createErrorFromCodeLookup.get(code)
  return createError != null ? createError() : null
}

/**
 * Attempts to resolve a custom program error from the provided error name, i.e. 'Unauthorized'.
 * @category Errors
 * @category generated
 */
export function errorFromName(name: string): MaybeErrorWithCode {
  const createError = createErrorFromNameLookup.get(name)
  return createError != null ? createError() : null
}
